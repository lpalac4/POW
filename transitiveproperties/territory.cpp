/** \file territory.cpp
 *  @brief Definitions of Territory member functions.
 *  @author Andrew Ring
 */

#include "territory.h"
#include "strengths.h"
#include "player.h"
#include "nullplayer.h"
#include <queue>
#include <set>

std::list<Territory*> Territory::allTerritoryList;
unsigned int** Territory::distanceArr;
bool Territory::distancesSet;
std::map<Territory*, int> Territory::territoryToDistanceIndex;

clock_t Territory::startTime;

/**
 * @brief Initializes the Territory with no generator or units and no neighbors.
 */
Territory::Territory()
{
    resourceGen = NONE;
    distancesSet = false;

    affectedByCity = false;
    Player* nullP = NullPlayer::getNullPlayer();
    ownedBy = nullP;
    nullP->territoryList->push_back(this);
    selected = false;
    stockpile = false;
    cityPresent = false;
    siloPresent = false;
    weaponPresent = false;
    boatPresent = false;
    horsePresent = false;
    wallPresent = false;
    ramPresent = false;

    adjacentTerritories = new std::list<Territory*>;
    adjacentWater = new std::list<Water*>;

    for(int i=0; i<9; i++){
        for(int k=0; k<2; k++){
            iconLocalesOrganizedByTypeOfIcon[i][k] = 0;
        }
    }

    Territory::allTerritoryList.push_back(this);
}

Territory::~Territory() {
    if(ownedBy) {
        ownedBy->territoryList->remove(this);
    }
    clearAdjacencies();
    delete(adjacentTerritories);
    delete(adjacentWater);

    Territory::allTerritoryList.remove(this);
}

void Territory::clearAdjacencies() {
    while(adjacentTerritories->size() > 0) {
        Territory* neighbor = adjacentTerritories->front();
        neighbor->adjacentTerritories->remove(this);
        adjacentTerritories->remove(neighbor);
    }
    while(adjacentWater->size() > 0) {
        Water* water = adjacentWater->front();
        water->adjacentTerritories->remove(this);
        adjacentWater->remove(water);
    }
}

/**
 * @brief Recalculates if there is a city affecting resource production.
 */
void Territory::cityCheck()
{
    std::list<Territory*>::iterator i;

    affectedByCity = cityPresent;

    Territory* currentTerritory;
    for(i=adjacentTerritories->begin();!affectedByCity && i != adjacentTerritories->end(); ++i) {
        currentTerritory = (*i);
        if(currentTerritory->cityPresent && currentTerritory->ownedBy == ownedBy) {
            affectedByCity = true;
        }
    }
}

/**
 * @brief Calculates the strength of the territory against attack, including
 * neighboring territories owned by the same player, but not including any ally support.
 * @return The strength of the territory against attack, not including ally support.
 */
int Territory::getDefensiveStrength()
{
    if(ownedBy == NullPlayer::getNullPlayer()) {
        // hack, fix later.
        return 1;
    }
    int strength = getStrength();
    if(boatPresent) strength += strengths::boat;
    if(wallPresent) strength += strengths::wall;

    std::list<Territory*>::iterator i;
    Territory* currentTerritory;
    for(i=adjacentTerritories->begin();i != adjacentTerritories->end(); ++i) {
        currentTerritory = (*i);
        if(currentTerritory->ownedBy == ownedBy) {
            strength += currentTerritory->getStrength();
        }
    }

    return strength;
}

/**
 * @brief Calculates the strength of the territory alone, with no offensive/defensive
 * only unit strength included.
 * @return The independed neutral strength of the territory.
 */
int Territory::getStrength()
{
    int strength = 1; // territory itself

    if(cityPresent) strength += strengths::city;
    if(weaponPresent) strength += strengths::weapon;
    if(horsePresent) strength += strengths::horse;
    // NOTE: Boats do NOT help you offensively unless brought to the target!

    return strength;
}

/**
 * @brief Calculates the total amount of resources that are generated by this territory.
 * This is 1 for resources generating territories with an additional 1 if affected by a
 * city and 1 if a Silo has been built here.  If there is no resource generator this
 * will always return 0 (cities do not cause resources to be generated in non-generating
 * territories and silos cannot be built on them anyways).  Note that this does not return
 * the type of resources.
 *
 * @return The amount of resources that are generated.
 */
int Territory::getNumResourcesGenerated()
{
    int num = 0;
    switch(this->resourceGen) {
    case NONE:
        return 0;
    case HORSE:
        return 1;
    case WOOD:
    case IRON:
    case STONE:
    case GOLD:
    case CROP:
        num = 1;
        if(this->affectedByCity) num++;
        if(this->siloPresent) num++;
        return num;
    case COUNT:
        // This should never happen!
        break;
    }
    // This should never happen!
    return -1;
}

Territory* Territory::generateHorse()
{

    if(!horsePresent) {
        horsePresent = true;
        return this;
    } else {
        Territory* target = findNearestWithNoHorse();
        if(target != 0) {
            target->horsePresent = true;
            return target;
        }
    }
    return NULL;
}

/**
 * @brief Searches (breadth first) for a Territory owned by the same Player without a horse which can be
 * reached through adjacent territories owned bu the same Player.
 * @return A pointer to the horse-less Territory, or NULL if none is found.
 */
Territory* Territory::findNearestWithNoHorse()
{
    std::set<Territory*> checked;
    std::queue<Territory*> frontier;
    Territory* focus;
    checked.insert(this);
    frontier.push(this);
    std::list<Territory*>::iterator i;

    while(frontier.size() > 0) {
        focus = frontier.front();
        frontier.pop();

        for(i = focus->adjacentTerritories->begin();i != focus->adjacentTerritories->end(); ++i) {
            Territory* current = (*i);
            if(current->ownedBy == this->ownedBy && checked.count(current) == 0) {
                if(!current->horsePresent) {
                    return current;
                } else {
                    checked.insert(current);
                    frontier.push(current);
                }
            }
        }
    }

    // If none is found
    return 0;
}

void Territory::calculateAllDistancesSimply()
{
    setDistanceIndices();

    std::list<Territory*>::iterator initialTerIter;

    for(initialTerIter = allTerritoryList.begin(); initialTerIter != allTerritoryList.end(); ++initialTerIter) {
        Territory* initialTerritory = (*initialTerIter);
        calculateDistancesSimply(initialTerritory);
    }
}

void Territory::calculateDistancesSimply(Territory* from) {
    std::set<Territory*> checked;
    std::queue<distanceAndTerritory*> frontier;
    distanceAndTerritory* focus;
    checked.insert(from);
    focus = new distanceAndTerritory;
    focus->territory = from;
    focus->distance = 0;
    frontier.push(focus);

    std::list<Territory*>::iterator i;

    while(frontier.size() > 0) {
        focus = frontier.front();
        frontier.pop();

        for(i = focus->territory->adjacentTerritories->begin();i != focus->territory->adjacentTerritories->end(); ++i) {
            Territory* current = (*i);
            if(checked.count(current) == 0) {
                distanceAndTerritory* dat = new distanceAndTerritory;
                dat->territory = current;
                dat->distance = focus->distance + 1;
                frontier.push(dat);
                checked.insert(current);
            }
        }

        distanceArr[territoryToDistanceIndex[from]][territoryToDistanceIndex[focus->territory]] = focus->distance;
    }
}

void Territory::setDistanceIndices(){
    if(allTerritoryList.empty() || distancesSet){
        return;
    }

    distancesSet = true;
    distanceArr = new unsigned int*[allTerritoryList.size()];
    for(unsigned int i = 0; i < allTerritoryList.size(); i++){
        distanceArr[i] = new unsigned int[allTerritoryList.size()];
        for(unsigned int j = 0; j < allTerritoryList.size(); j++){
            distanceArr[i][j] = 10000;
        }
    }

    std::list<Territory*>::iterator iter;
    int i = 0;
    for(iter = allTerritoryList.begin(); iter != allTerritoryList.end(); iter++, i++){
        territoryToDistanceIndex[*iter] = i;
    }
}

void Territory::calculateDistances(Territory* newTerritory, std::list<Territory*> &frontier, std::set<Territory*> &visited,
                                   int depthOfFrontier){
    Territory* expandingTerritory;
    std::list<Territory*> newFrontier;

    while(!frontier.empty()){
        expandingTerritory = frontier.front();
        frontier.pop_front();

        if(visited.count(expandingTerritory) == 0){
            visited.insert(expandingTerritory);
            distanceArr[territoryToDistanceIndex[newTerritory]][territoryToDistanceIndex[expandingTerritory]]
                    = depthOfFrontier;

            for(std::list<Territory*>::iterator iter = expandingTerritory->adjacentTerritories->begin();
                iter != expandingTerritory->adjacentTerritories->end(); iter++){
                newFrontier.push_back(*iter);
            }
        }

        if(newFrontier.empty()){
            return;
        }
        calculateDistances(newTerritory, newFrontier, visited, depthOfFrontier + 1);
    }
}

void Territory::calculateDistances(Territory* newTerritory){
    std::list<Territory*> frontier;
    std::set<Territory*> visited;
    frontier.push_back(newTerritory);
    calculateDistances(newTerritory, frontier, visited, 0);
}

bool Territory::isNeighbor(Territory* otherCountry){
    std::list<Territory*>::iterator iterate = adjacentTerritories->begin();
    while(iterate != adjacentTerritories->end()){
        if(*iterate == otherCountry){
            return true;
        }
        iterate++;
    }
    return false;
}

/**
 * @brief Changes ownership of the Territory.  This includes removing from current owners list
 * of territories, adding to new owners list, updating internal owner pointer, updating cityAffected
 * status of self and all neighbors.
 * @param newOwner The new owner of this Territory.
 */
void Territory::changeOwnershipTo(Player* newOwner)
{
    if(newOwner == ownedBy) {
        return;
    }

    ownedBy->territoryList->remove(this);
    newOwner->territoryList->push_back(this);
    ownedBy = newOwner;

    cityCheck();

    radialCityCheck();
}

/**
 * @brief Updates the city present status for a territory and all surounding territories (radius 1).
 */
void Territory::radialCityCheck()
{
    cityCheck();

    std::list<Territory*>::iterator i;
    for(i = adjacentTerritories->begin(); i != adjacentTerritories->end(); ++i) {
        Territory* currentTerritory = (*i);
        currentTerritory->cityCheck();
    }
}

void Territory::calculateAllDistances(){
    if(testingFlags::TEST_CALC_RUNTIME) {
        Territory::startTime = clock();
    }
    unsigned int iterCount = 0;
    setDistanceIndices();
    for(std::list<Territory*>::iterator iter = allTerritoryList.begin(); iter != allTerritoryList.end(); iter++){
        if(testingFlags::TEST_CALC_RUNTIME) {
            double elapsedTime = double(clock() - Territory::startTime)/CLOCKS_PER_SEC;
            qDebug() << "calculateAllDistances() at loop " << ++iterCount << ", " << elapsedTime << " seconds from starting...";
        }
        calculateDistances(*iter);
    }
    if(testingFlags::TEST_CALC_RUNTIME) {
        double elapsedTime = double(clock() - Territory::startTime)/CLOCKS_PER_SEC;
        qDebug() << "calculateAllDistances() took " << elapsedTime << " seconds";
    }
}

int Territory::getDistance(Territory* a, Territory* b){
    return distanceArr[territoryToDistanceIndex[a]][territoryToDistanceIndex[b]];
}
